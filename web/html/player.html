<!--
generate a new player page.
it should have 2 mode collapsed and expanded
when expanded, it should have a <h4> to display the episode title, a player UI and a list of queued episodes. 
the list should show episode title and start position / duration of the episode
when collapsed, it should have a <h5> to display the episode title and a player UI and a button to expand.
the page should have a html5 audio player but no visible, 
all visible controls UI should be buttons with frontawesome icons (from cdn)
the control buttons should be "previous episode", "rewind", "play/pause", "forward", "next episode", "restart from beginning"
all buttons should be icon only without text
when page loaded, it should fetch all queued episodes from /api/queue, and set source to the first episode of the queue at the start_pos but don't auto start playing audio
when one episode is played, move to play next episode from it's start_pos, don't remove the finished episode from queue.
the page is designed to be displayed in a iframe in index.html. when collapsed, the iframe should be 15vh in height.
when expanded, the iframe should be 50vh in height.
but for now, only generate the html for player_new.html don't change index.html
don't remove this comment after generating code
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Player (New)</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/player.css">
</head>
<body class="collapsed">
  <div class="player-shell">
    <div class="title-row">
      <div class="title-text collapsed-only">
        <h5 id="title-sm">Loading episode...</h5>
        <div class="subtitle" id="meta-sm">Waiting for queue</div>
      </div>
      <div class="title-text expanded-only">
        <h4 id="title-lg">Loading episode...</h4>
        <div class="subtitle" id="meta-lg">Waiting for queue</div>
      </div>
      <button class="icon-btn ghost" id="toggle-mode" aria-label="Expand player">
        <i class="fa-solid fa-up-right-and-down-left-from-center" id="toggle-icon"></i>
      </button>
    </div>

    <div class="controls">
      <div class="progress-wrap">
        <input type="range" id="progress" min="0" max="0" step="0.1" value="0" aria-label="Seek through episode">
        <div class="time-readout" id="time-readout">00:00 / --:--</div>
      </div>
      <div class="control-bar">
        <button class="icon-btn" id="prev-btn" aria-label="Previous episode">
          <i class="fa-solid fa-backward-step"></i>
        </button>
        <button class="icon-btn" id="rewind-btn" aria-label="Rewind 10 seconds">
          <i class="fa-solid fa-backward"></i>
        </button>
        <button class="icon-btn primary" id="play-btn" aria-label="Play or pause">
          <i class="fa-solid fa-play" id="play-icon"></i>
        </button>
        <button class="icon-btn" id="forward-btn" aria-label="Forward 10 seconds">
          <i class="fa-solid fa-forward"></i>
        </button>
        <button class="icon-btn" id="next-btn" aria-label="Next episode">
          <i class="fa-solid fa-forward-step"></i>
        </button>
        <button class="icon-btn" id="restart-btn" aria-label="Restart from beginning">
          <i class="fa-solid fa-rotate-left"></i>
        </button>
      </div>
    </div>

    <div class="queue expanded-only">
      <div class="queue-header">
        <span>Queue</span>
        <span class="pill" id="queue-count">0 items</span>
      </div>
      <ul id="queue-list"></ul>
    </div>

    <audio id="audio-player" preload="auto"></audio>
  </div>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
  <script src="/js/main.js"></script>
  <script>
    (() => {
      const body = document.body;
      const audioEl = document.getElementById('audio-player');
      const playBtn = document.getElementById('play-btn');
      const playIcon = document.getElementById('play-icon');
      const prevBtn = document.getElementById('prev-btn');
      const nextBtn = document.getElementById('next-btn');
      const rewindBtn = document.getElementById('rewind-btn');
      const forwardBtn = document.getElementById('forward-btn');
      const restartBtn = document.getElementById('restart-btn');
      const queueListEl = document.getElementById('queue-list');
      const queueCountEl = document.getElementById('queue-count');
      const timeReadout = document.getElementById('time-readout');
      const progressEl = document.getElementById('progress');
      const titleSmall = document.getElementById('title-sm');
      const titleLarge = document.getElementById('title-lg');
      const metaSmall = document.getElementById('meta-sm');
      const metaLarge = document.getElementById('meta-lg');
      const toggleModeBtn = document.getElementById('toggle-mode');
      const toggleIcon = document.getElementById('toggle-icon');

      let queue = [];
      let pods = [];
      let currentEpisode = '';
      let pendingSeek = 0;
      let shouldAutoplay = false;
      let userSeeking = false;
      let progressSaveTimer = null;

      function notifyMode(mode) {
        try {
          window.parent?.postMessage({ type: 'player-new-mode', mode }, '*');
        } catch (err) {
          console.warn('Failed to notify parent', err);
        }
      }

      function formatSeconds(seconds) {
        if (!Number.isFinite(seconds) || seconds < 0) return '0:00';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      function parseDuration(raw) {
        if (!raw) return NaN;
        const parts = raw.split(':').map(Number);
        if (parts.some(n => Number.isNaN(n))) return NaN;
        if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
        if (parts.length === 2) return parts[0] * 60 + parts[1];
        return NaN;
      }

      function resolveEpisode(item) {
        const pod = pods.find(p => p.id === item.pod_id);
        const episode = pod?.episodes?.find(ep => `${ep.index}` === `${item.episode_idx}`) ??
          pod?.episodes?.[item.episode_idx];
        const durationSeconds = parseDuration(episode?.duration || '');
        return {
          title: episode?.title || `Episode ${item.episode_idx}`,
          audioUrl: episode?.audio_url || '',
          podTitle: pod?.title || item.pod_id,
          durationLabel: episode?.duration || (Number.isFinite(durationSeconds) ? formatSeconds(durationSeconds) : '--:--'),
          durationSeconds
        };
      }

      function getEpisodeKey(item) {
        if (!item) return '';
        return `${item.pod_id}_${item.episode_idx}`;
      }

      function getCurrentIndex() {
        if (!currentEpisode) return -1;
        return queue.findIndex(item => getEpisodeKey(item) === currentEpisode);
      }

      function getCurrentItem() {
        const idx = getCurrentIndex();
        return idx >= 0 ? queue[idx] : null;
      }

      async function updateQueueCurrentFlag(item, isCurrent) {
        if (!item) return;
        try {
          const res = await fetchWithRefresh('/api/queue', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              pod_id: item.pod_id,
              episode_idx: item.episode_idx,
              start_pos: Number(item.start_pos) || 0,
              is_current: isCurrent
            })
          });
          if (!res.ok) throw new Error('Failed to update queue item');
          item.is_current = isCurrent;
        } catch (err) {
          console.error(err);
        }
      }

      async function updateQueueStartPos(item, startPos) {
        if (!item) return;
        try {
          const res = await fetchWithRefresh('/api/queue', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              pod_id: item.pod_id,
              episode_idx: item.episode_idx,
              start_pos: Math.max(0, Math.floor(Number(startPos) || 0)),
              is_current: !!item.is_current
            })
          });
          if (!res.ok) throw new Error('Failed to update start_pos');
          item.start_pos = Math.max(0, Math.floor(Number(startPos) || 0));
        } catch (err) {
          console.error(err);
        }
      }

      function startProgressSaver() {
        if (progressSaveTimer) return;
        progressSaveTimer = window.setInterval(() => {
          if (!queue.length || audioEl.paused) return;
          const item = getCurrentItem();
          if (!item) return;
          void updateQueueStartPos(item, audioEl.currentTime || 0);
        }, 10000);
      }

      function stopProgressSaver() {
        if (!progressSaveTimer) return;
        window.clearInterval(progressSaveTimer);
        progressSaveTimer = null;
      }

      async function ensureFirstCurrentFlag() {
        if (queue.length === 1 && !queue[0].is_current) {
          queue[0].is_current = true;
          await updateQueueCurrentFlag(queue[0], true);
        }
      }

      async function setCurrentIndex(nextIndex, { autoplay = false } = {}) {
        if (nextIndex < 0 || nextIndex >= queue.length) return;
        const prevIndex = getCurrentIndex();
        const nextItem = queue[nextIndex];
        if (nextIndex === prevIndex) {
          if (nextItem && !nextItem.is_current) {
            nextItem.is_current = true;
            await updateQueueCurrentFlag(nextItem, true);
          }
          currentEpisode = getEpisodeKey(nextItem);
          loadCurrentTrack({ autoplay });
          return;
        }
        const prevItem = queue[prevIndex];
        if (prevItem) prevItem.is_current = false;
        if (nextItem) nextItem.is_current = true;
        currentEpisode = getEpisodeKey(nextItem);
        loadCurrentTrack({ autoplay });
        await Promise.all([
          updateQueueCurrentFlag(prevItem, false),
          updateQueueCurrentFlag(nextItem, true)
        ]);
      }

      function updateTitles() {
        const item = getCurrentItem();
        if (!item) {
          titleSmall.textContent = 'Nothing queued';
          titleLarge.textContent = 'Nothing queued';
          metaSmall.textContent = 'Queue an episode to start';
          metaLarge.textContent = 'Queue an episode to start';
          return;
        }
        const ep = resolveEpisode(item);
        const start = formatSeconds(Number(item.start_pos) || 0);
        titleSmall.textContent = ep.title;
        titleLarge.textContent = ep.title;
        const meta = `${ep.podTitle}`;
        metaSmall.textContent = meta;
        metaLarge.textContent = meta;
      }

      function renderQueue() {
        queueListEl.innerHTML = '';
        queueCountEl.textContent = `${queue.length} item${queue.length === 1 ? '' : 's'}`;
        if (!queue.length) {
          const empty = document.createElement('li');
          empty.className = 'queue-empty';
          empty.style.color = '#94a3b8';
          empty.textContent = 'Your queue is empty.';
          queueListEl.appendChild(empty);
          return;
        }
        const currentIdx = getCurrentIndex();
        queue.forEach((item, idx) => {
          const ep = resolveEpisode(item);
          const li = document.createElement('li');
          if (idx === currentIdx) li.classList.add('active');
          const info = document.createElement('div');
          const title = document.createElement('div');
          title.className = 'queue-item-title';
          title.textContent = ep.title;
          const meta = document.createElement('div');
          meta.className = 'queue-item-meta';
          const start = formatSeconds(Number(item.start_pos) || 0);
          meta.textContent = `${ep.podTitle} â€¢ Start ${start}${ep.durationLabel ? ' / ' + ep.durationLabel : ''}`;
          info.appendChild(title);
          info.appendChild(meta);

          const badge = document.createElement('span');
          badge.className = 'pill';
          badge.textContent = `#${item.idx}`;

          const actions = document.createElement('div');
          actions.className = 'queue-actions';
          const removeBtn = document.createElement('button');
          removeBtn.className = 'queue-remove';
          removeBtn.setAttribute('aria-label', 'Remove from queue');
          removeBtn.setAttribute('data-queue-idx', item.idx);
          removeBtn.innerHTML = '<i class="fa-solid fa-trash-can"></i>';
          actions.appendChild(removeBtn);

          li.appendChild(info);
          const right = document.createElement('div');
          right.className = 'queue-actions';
          right.appendChild(badge);
          right.appendChild(actions);
          li.appendChild(right);
          queueListEl.appendChild(li);
        });
      }

      function updateControlsState() {
        const hasQueue = queue.length > 0;
        const currentIdx = getCurrentIndex();
        playBtn.disabled = !hasQueue;
        prevBtn.disabled = !hasQueue || currentIdx <= 0;
        nextBtn.disabled = !hasQueue || currentIdx === -1 || currentIdx >= queue.length - 1;
        rewindBtn.disabled = !hasQueue;
        forwardBtn.disabled = !hasQueue;
        restartBtn.disabled = !hasQueue;
        progressEl.disabled = !hasQueue;
      }

      function updateTime(displayOverride) {
        const dur = Number.isFinite(audioEl.duration)
          ? audioEl.duration
          : Math.max(audioEl.currentTime || 0, pendingSeek || 0, 600);
        const currentVal = typeof displayOverride === 'number' ? displayOverride : (audioEl.currentTime || 0);
        if (!userSeeking) {
          progressEl.max = dur;
          progressEl.value = Math.min(currentVal, dur);
        }
        const current = formatSeconds(currentVal);
        const total = Number.isFinite(audioEl.duration) ? formatSeconds(audioEl.duration) : '--:--';
        timeReadout.textContent = `${current} / ${total}`;
      }

      function updatePlayIcon() {
        playIcon.className = audioEl.paused ? 'fa-solid fa-play' : 'fa-solid fa-pause';
      }

      function loadCurrentTrack({ autoplay = false } = {}) {
        const item = getCurrentItem();
        if (!item) {
          currentEpisode = '';
          audioEl.removeAttribute('src');
          updateTitles();
          updateControlsState();
          return;
        }
        currentEpisode = getEpisodeKey(item);
        const ep = resolveEpisode(item);
        if (!ep.audioUrl) {
          return;
        }
        shouldAutoplay = autoplay;
        pendingSeek = Number(item.start_pos) || 0;
        audioEl.src = ep.audioUrl;
        audioEl.load();
        progressEl.value = 0;
        progressEl.max = 0;
        updateTitles();
        updateControlsState();
        renderQueue();
      }

      async function fetchData() {
        const previousEpisode = currentEpisode;
        try {
          const [podsRes, queueRes] = await Promise.all([
            fetchWithRefresh('/api/get_pods'),
            fetchWithRefresh('/api/queue')
          ]);
          if (!podsRes.ok) throw new Error('Failed to fetch pods');
          if (!queueRes.ok) throw new Error('Failed to fetch queue');
          pods = await podsRes.json();
          queue = await queueRes.json();
          if (!queue.length) {
            currentEpisode = '';
            audioEl.pause();
            audioEl.removeAttribute('src');
            audioEl.load();
            renderQueue();
            updateTitles();
            updateControlsState();
            return;
          }

          const flaggedIdx = queue.findIndex(item => item.is_current);
          if (flaggedIdx >= 0) {
            currentEpisode = getEpisodeKey(queue[flaggedIdx]);
          } else if (previousEpisode) {
            const foundIdx = queue.findIndex(item => getEpisodeKey(item) === previousEpisode);
            if (foundIdx >= 0) {
              currentEpisode = previousEpisode;
            } else {
              currentEpisode = getEpisodeKey(queue[0]);
            }
          } else {
            currentEpisode = getEpisodeKey(queue[0]);
          }

          await ensureFirstCurrentFlag();
          renderQueue();
          updateTitles();
          updateControlsState();
          if (currentEpisode !== previousEpisode) {
            
            loadCurrentTrack({ autoplay: false });
          }

        } catch (err) {
          console.error(err);
        }
      }

    

      function toggleMode() {
        const shouldExpand = body.classList.contains('collapsed');
        body.classList.toggle('collapsed', !shouldExpand);
        body.classList.toggle('expanded', shouldExpand);
        const mode = shouldExpand ? 'expanded' : 'collapsed';
        toggleIcon.className = shouldExpand
          ? 'fa-solid fa-down-left-and-up-right-to-center'
          : 'fa-solid fa-up-right-and-down-left-from-center';
        notifyMode(mode);
      }

      playBtn.addEventListener('click', () => {
        if (!queue.length) return;
        if (audioEl.paused) {
          audioEl.play().catch(() => {});
        } else {
          audioEl.pause();
        }
      });

      restartBtn.addEventListener('click', () => {
        if (!queue.length) return;
        const currentIdx = getCurrentIndex();
        if (currentIdx < 0) return;
        audioEl.currentTime = 0;
        updateTime();
        void updateQueueStartPos(queue[currentIdx], 0);
        if (audioEl.paused && shouldAutoplay) {
          audioEl.play().catch(() => {});
        }
      });

      rewindBtn.addEventListener('click', () => {
        if (!queue.length) return;
        const currentIdx = getCurrentIndex();
        if (currentIdx < 0) return;
        audioEl.currentTime = Math.max(0, (audioEl.currentTime || 0) - 10);
        updateTime();
        void updateQueueStartPos(queue[currentIdx], audioEl.currentTime || 0);
      });

      forwardBtn.addEventListener('click', () => {
        if (!queue.length) return;
        const currentIdx = getCurrentIndex();
        if (currentIdx < 0) return;
        const duration = Number.isFinite(audioEl.duration) ? audioEl.duration : (audioEl.currentTime || 0) + 10;
        audioEl.currentTime = Math.min(duration, (audioEl.currentTime || 0) + 10);
        updateTime();
        void updateQueueStartPos(queue[currentIdx], audioEl.currentTime || 0);
      });

      nextBtn.addEventListener('click', () => {
        const currentIdx = getCurrentIndex();
        if (currentIdx < 0 || currentIdx >= queue.length - 1) return;
        void updateQueueStartPos(queue[currentIdx], audioEl.currentTime || 0);
        void setCurrentIndex(currentIdx + 1, { autoplay: true });
      });

      prevBtn.addEventListener('click', () => {
        if (!queue.length) return;
        const currentIdx = getCurrentIndex();
        if (currentIdx < 0) return;
        if (currentIdx === 0) {
          audioEl.currentTime = 0;
          updateTime();
          void updateQueueStartPos(queue[currentIdx], 0);
          return;
        }
        void updateQueueStartPos(queue[currentIdx], audioEl.currentTime || 0);
        void setCurrentIndex(currentIdx - 1, { autoplay: true });
      });

      toggleModeBtn.addEventListener('click', toggleMode);

      audioEl.addEventListener('loadedmetadata', () => {
        if (pendingSeek > 0) {
          const target = Number.isFinite(audioEl.duration)
            ? Math.min(pendingSeek, audioEl.duration)
            : pendingSeek;
          audioEl.currentTime = target;
        }
        updateTime();
        if (shouldAutoplay) {
          audioEl.play().catch(() => {});
        }
        shouldAutoplay = false;
      });

      audioEl.addEventListener('timeupdate', () => updateTime());
      audioEl.addEventListener('play', () => {
        updatePlayIcon();
        startProgressSaver();
      });
      audioEl.addEventListener('pause', () => {
        updatePlayIcon();
        stopProgressSaver();
        if (queue.length) {
          const currentItem = getCurrentItem();
          if (currentItem) {
            void updateQueueStartPos(currentItem, audioEl.currentTime || 0);
          }
        }
      });
      audioEl.addEventListener('ended', () => {
        stopProgressSaver();
        if (queue.length) {
          const currentItem = getCurrentItem();
          if (currentItem) {
            void updateQueueStartPos(currentItem, audioEl.currentTime || 0);
          }
        }
        const currentIdx = getCurrentIndex();
        if (currentIdx >= 0 && currentIdx < queue.length - 1) {
          void setCurrentIndex(currentIdx + 1, { autoplay: true });
        } else {
          updatePlayIcon();
        }
      });

      progressEl.addEventListener('pointerdown', () => {
        userSeeking = true;
      });

      progressEl.addEventListener('input', (e) => {
        const val = Number(e.target.value) || 0;
        updateTime(val);
      });

      progressEl.addEventListener('change', (e) => {
        const val = Number(e.target.value) || 0;
        userSeeking = false;
        audioEl.currentTime = val;
        updateTime();
        if (queue.length) {
          const currentItem = getCurrentItem();
          if (currentItem) {
            void updateQueueStartPos(currentItem, val);
          }
        }
      });

      progressEl.addEventListener('pointerup', () => {
        userSeeking = false;
      });

      queueListEl.addEventListener('click', async (e) => {
        const btn = e.target.closest('.queue-remove');
        if (!btn) return;
        e.preventDefault();
        const idx = btn.getAttribute('data-queue-idx');
        if (!idx) return;
        const idxNum = Number(idx);
        if (!Number.isFinite(idxNum)) return;
        const currentIdx = getCurrentIndex();
        const deletingCurrent = queue[currentIdx]?.idx === idxNum;
        const hasNext = deletingCurrent && currentIdx < queue.length - 1;
        if (deletingCurrent && hasNext) {
          await setCurrentIndex(currentIdx + 1, { autoplay: !audioEl.paused });
        } 
        else if (deletingCurrent) {
          audioEl.pause();
          audioEl.removeAttribute('src');
          audioEl.load();
          updateTitles();
          updateControlsState();
          window.parent?.postMessage({ type: 'hide-player-iframe' }, '*');
        }

        try {
          const res = await fetchWithRefresh(`/api/queue/${idx}`, {
            method: 'DELETE',
          });
          if (!res.ok) throw new Error('Failed to delete');
          await fetchData();
          window.parent?.postMessage({ type: 'queue-updated' }, '*');
        } catch (err) {
          console.error(err);
        }
      });

      window.addEventListener('message', (event) => {
        if (event?.data?.type === 'reload-queue') {
          fetchData();
        }
      });

      window.addEventListener('DOMContentLoaded', () => {
        notifyMode('collapsed');
        fetchData();
      });
    })();
  </script>
</body>
</html>
