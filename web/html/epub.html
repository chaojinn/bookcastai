<!--
this page should use epub.css under css folder for styling, create empty style file if not exist
this page should use jquery and bootstrap in the same style as index.html
this page will have a responsive design and look proper on all device sizes
this page will have:
a pod_title parameter passed via URI
a button "Parse EPUB" to start parsing the EPUB file
a code editor component from https://codemirror.net/, reference the code using cdn
a status bar to show parsing status and error messages
a progress bar to show parsing progress

when page loaded, it should use /api/epub/{pod_title} to check if the EPUB file exists, /api/epub/{pod_title} should be implemented in api/epub.py
/api/epub/{pod_title} should check if base_dir/{pod_title}/book.epub exists (base_dir = os.getenv("PODS_BASE")), if not exist, return 404, else return 200 
if file exists, enable "Parse EPUB" button, otherwise disable it and show error message "EPUB file not found"
if book.epub exists, use /api/epub_result/{pod_title} to check if base_dir/{pod_title}/book.json exists,
if not return 404, else return the content of book.json and display it in code editor

-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EPUB Parser</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/fold/foldgutter.min.css" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/epub.css">
</head>
<body>
  <main class="page-shell">
    <header class="page-header">
      <div>
        <h1>EPUB Parser</h1>
        <p class="subtitle">Pod: <span id="pod-title">Unknown</span></p>
      </div>
      <button class="btn btn-primary" id="parse-btn" disabled>
        <i class="fa-solid fa-wand-magic-sparkles"></i> Parse EPUB
      </button>
    </header>

    <section class="panel">
      <div class="controls">
        <div class="progress d-none" role="progressbar" aria-label="Parsing progress">
          <div id="progress-bar" class="progress-bar" style="width: 0%"></div>
        </div>
      </div>
      <div id="status-bar" class="status-bar">Ready.</div>
    </section>

    <section class="cover-card" id="cover-card" aria-live="polite">
      <div class="cover-header">
        <span class="cover-title">Cover image</span>
      </div>
      <div class="cover-frame">
        <img id="cover-image" class="cover-image d-none" alt="EPUB cover image">
        <div id="cover-placeholder" class="cover-placeholder">No cover image available.</div>
      </div>
    </section>

    <section class="summary-card" id="summary-card">
      <div class="summary-header">
        <div>
          <h2 class="summary-title">Summary</h2>
          <p class="summary-subtitle">Derived from parsed JSON output.</p>
        </div>
        <button class="btn btn-outline-secondary btn-sm" id="show-raw-btn" type="button">
          Show raw data
        </button>
      </div>
      <div class="summary-grid">
        <div class="summary-item">
          <div class="summary-label">Title</div>
          <div id="summary-title" class="summary-value">—</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Chapters</div>
          <div id="summary-chapters" class="summary-value">—</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">First chapter</div>
          <div id="summary-first" class="summary-value">—</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Last chapter</div>
          <div id="summary-last" class="summary-value">—</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Average words per chapter</div>
          <div id="summary-average" class="summary-value">—</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Longest chapter</div>
          <div id="summary-longest" class="summary-value">—</div>
        </div>
        <div class="summary-item">
          <div class="summary-label">Shortest chapter</div>
          <div id="summary-shortest" class="summary-value">—</div>
        </div>
      </div>
    </section>

    <section class="editor-card is-hidden">
      <textarea id="editor" aria-label="EPUB JSON output"></textarea>
    </section>
  </main>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/fold/foldcode.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/fold/foldgutter.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/fold/brace-fold.min.js" crossorigin="anonymous"></script>
  <script src="/js/main.js"></script>
  <script>
    $(function () {
      const params = new URLSearchParams(window.location.search);
      const podTitle = params.get('pod_title');

      const podTitleEl = $('#pod-title');
      const parseBtn = $('#parse-btn');
      const statusBar = $('#status-bar');
      const progressBar = $('#progress-bar');
      const progressWrap = $('.progress');
      const coverCard = $('#cover-card');
      const coverImage = $('#cover-image');
      const coverPlaceholder = $('#cover-placeholder');
      const editorCard = $('.editor-card');
      const showRawBtn = $('#show-raw-btn');
      const summaryTitle = $('#summary-title');
      const summaryChapters = $('#summary-chapters');
      const summaryFirst = $('#summary-first');
      const summaryLast = $('#summary-last');
      const summaryAverage = $('#summary-average');
      const summaryLongest = $('#summary-longest');
      const summaryShortest = $('#summary-shortest');

      let rawDataAvailable = false;
      let rawDataVisible = false;

      const editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
        lineNumbers: true,
        mode: { name: 'javascript', json: true },
        lineWrapping: true,
        theme: 'default',
        foldGutter: true,
        gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter']
      });

      function findFirstLevelFoldPositions(text) {
        const positions = [];
        let line = 0;
        let ch = 0;
        let depth = 0;
        let inString = false;
        let escaped = false;

        for (let i = 0; i < text.length; i += 1) {
          const c = text[i];
          if (c === '\n') {
            line += 1;
            ch = 0;
            continue;
          }
          if (c === '\r') {
            continue;
          }
          if (inString) {
            if (escaped) {
              escaped = false;
            } else if (c === '\\') {
              escaped = true;
            } else if (c === '"') {
              inString = false;
            }
          } else if (c === '"') {
            inString = true;
          } else if (c === '{' || c === '[') {
            if (depth === 1) {
              positions.push({ line, ch });
            }
            depth += 1;
          } else if (c === '}' || c === ']') {
            if (depth > 0) depth -= 1;
          }
          ch += 1;
        }

        return positions;
      }

      function applyInitialFolds() {
        const text = editor.getValue();
        if (!text) return;
        editor.operation(() => {
          editor.execCommand('unfoldAll');
          const positions = findFirstLevelFoldPositions(text);
          positions.forEach((pos) => editor.foldCode(pos, null, 'fold'));
        });
      }

      function setStatus(message, variant) {
        statusBar
          .removeClass('status-error status-success status-info')
          .addClass(variant ? `status-${variant}` : '')
          .text(message || '');
      }

      function startProgress() {
        progressWrap.removeClass('d-none');
        progressBar
          .addClass('progress-bar-striped progress-bar-animated')
          .css('width', '0%');
      }

      function stopProgress() {
        progressBar
          .removeClass('progress-bar-striped progress-bar-animated')
          .css('width', '0%');
        progressWrap.addClass('d-none');
      }

      function updateProgress(value) {
        const numeric = Number(value);
        const clamped = Number.isFinite(numeric) ? Math.max(0, Math.min(100, numeric)) : 0;
        progressBar.css('width', `${clamped}%`);
        return Math.round(clamped);
      }

      function setJobStatus(status, progress, message) {
        const percent = updateProgress(progress);
        const text = message ? `${percent}% - ${message}` : `${percent}%`;
        if (status === 'success') {
          setStatus(text, 'success');
          return;
        }
        if (status === 'fail' || status === 'cancelled') {
          setStatus(text, 'error');
          return;
        }
        setStatus(text, 'info');
      }

      function setRawState({ available, visible } = {}) {
        if (typeof available === 'boolean') {
          rawDataAvailable = available;
        }
        if (typeof visible === 'boolean') {
          rawDataVisible = visible;
        }
        if (!rawDataAvailable) {
          editorCard.addClass('is-hidden');
          showRawBtn.prop('disabled', true).text('Show raw data');
          return;
        }
        if (rawDataVisible) {
          editorCard.removeClass('is-hidden');
          showRawBtn.prop('disabled', false).text('Hide raw data');
          editor.refresh();
          return;
        }
        editorCard.addClass('is-hidden');
        showRawBtn.prop('disabled', false).text('Show raw data');
      }

      function formatWordCount(value) {
        const number = Number(value);
        if (!Number.isFinite(number)) return '0';
        return number.toLocaleString();
      }

      function countWords(text) {
        if (typeof text !== 'string') return 0;
        const cleaned = text.replace(/\s+/g, ' ').trim();
        if (!cleaned) return 0;
        return cleaned.split(' ').length;
      }

      function formatChapterLabel(chapter, fallbackNumber) {
        const number = Number.isFinite(Number(chapter?.chapter_number))
          ? Number(chapter.chapter_number)
          : fallbackNumber;
        const title = typeof chapter?.chapter_title === 'string'
          ? chapter.chapter_title.trim()
          : '';
        return title ? `Chapter ${number}: ${title}` : `Chapter ${number}`;
      }

      function setSummaryEmpty() {
        summaryTitle.text('—');
        summaryChapters.text('—');
        summaryFirst.text('—');
        summaryLast.text('—');
        summaryAverage.text('—');
        summaryLongest.text('—');
        summaryShortest.text('—');
      }

      function updateSummaryFromData(data) {
        if (!data || typeof data !== 'object') {
          setSummaryEmpty();
          return;
        }
        const titleCandidate = typeof data.title === 'string' ? data.title.trim() : '';
        const fallbackTitle = typeof data.metadata?.title === 'string' ? data.metadata.title.trim() : '';
        const title = titleCandidate || fallbackTitle || podTitle || 'Unknown';
        const chapters = Array.isArray(data.chapters) ? data.chapters : [];
        summaryTitle.text(title);
        summaryChapters.text(chapters.length ? chapters.length.toString() : '0');

        if (!chapters.length) {
          summaryFirst.text('—');
          summaryLast.text('—');
          summaryAverage.text('—');
          summaryLongest.text('—');
          summaryShortest.text('—');
          return;
        }

        summaryFirst.text(formatChapterLabel(chapters[0], 1));
        summaryLast.text(formatChapterLabel(chapters[chapters.length - 1], chapters.length));

        let totalWords = 0;
        let longestIndex = 0;
        let shortestIndex = 0;
        let longestCount = -1;
        let shortestCount = Number.POSITIVE_INFINITY;

        chapters.forEach((chapter, index) => {
          const words = countWords(chapter?.content_text);
          totalWords += words;
          if (words > longestCount) {
            longestCount = words;
            longestIndex = index;
          }
          if (words < shortestCount) {
            shortestCount = words;
            shortestIndex = index;
          }
        });

        const average = Math.round(totalWords / chapters.length);
        summaryAverage.text(`${formatWordCount(average)} words`);
        summaryLongest.text(
          `${formatChapterLabel(chapters[longestIndex], longestIndex + 1)} — ${formatWordCount(longestCount)} words`
        );
        summaryShortest.text(
          `${formatChapterLabel(chapters[shortestIndex], shortestIndex + 1)} — ${formatWordCount(shortestCount)} words`
        );
      }

      function setCoverImage(base64, mediaType) {
        if (typeof base64 !== 'string' || !base64.trim()) {
          coverImage.attr('src', '').addClass('d-none');
          coverPlaceholder.removeClass('d-none');
          coverCard.addClass('is-empty');
          return;
        }
        const trimmed = base64.trim();
        const hasDataPrefix = trimmed.toLowerCase().startsWith('data:');
        const type = typeof mediaType === 'string' && mediaType.trim()
          ? mediaType.trim()
          : 'image/jpeg';
        const src = hasDataPrefix ? trimmed : `data:${type};base64,${trimmed}`;
        coverImage.attr('src', src).removeClass('d-none');
        coverPlaceholder.addClass('d-none');
        coverCard.removeClass('is-empty');
      }

      function updateParsedOutput(text) {
        if (!text) {
          setCoverImage(null);
          updateSummaryFromData(null);
          setRawState({ available: false, visible: false });
          return;
        }
        try {
          const data = JSON.parse(text);
          setCoverImage(data.cover_image, data.cover_image_media_type);
          updateSummaryFromData(data);
          setRawState({ available: true });
        } catch (err) {
          console.warn('Failed to parse cover image from JSON.', err);
          setCoverImage(null);
          updateSummaryFromData(null);
          setRawState({ available: false, visible: false });
        }
      }

      async function loadResult({ setEmptyStatus = false } = {}) {
        if (!podTitle) return false;
        try {
          const res = await fetchWithRefresh(`/api/epub_result/${encodeURIComponent(podTitle)}`);
          if (res.ok) {
            const text = await res.text();
            editor.setValue(text || '');
            applyInitialFolds();
            updateParsedOutput(text);
            setStatus('Loaded parsed JSON output.', 'success');
            return true;
          }
          if (res.status === 404) {
            if (setEmptyStatus) {
              setStatus('No parsed output found yet.', 'info');
            }
            setCoverImage(null);
            updateSummaryFromData(null);
            setRawState({ available: false, visible: false });
            return false;
          }
          throw new Error('Unexpected response');
        } catch (err) {
          console.warn('Failed to load EPUB result', err);
          setStatus('Failed to load parsed output.', 'error');
          updateSummaryFromData(null);
          setRawState({ available: false, visible: false });
          return false;
        }
      }

      async function checkEpub() {
        if (!podTitle) {
          setStatus('Missing pod_title in URL.', 'error');
          parseBtn.prop('disabled', true);
          setCoverImage(null);
          updateSummaryFromData(null);
          setRawState({ available: false, visible: false });
          return;
        }
        podTitleEl.text(podTitle);
        setStatus('Checking EPUB...', 'info');
        try {
          const res = await fetchWithRefresh(`/api/epub/${encodeURIComponent(podTitle)}`);
          if (res.ok) {
            parseBtn.prop('disabled', false);
            await loadResult({ setEmptyStatus: true });
            return;
          }
          if (res.status === 404) {
            parseBtn.prop('disabled', true);
            setStatus('EPUB file not found', 'error');
            setCoverImage(null);
            updateSummaryFromData(null);
            setRawState({ available: false, visible: false });
            return;
          }
          throw new Error('Unexpected response');
        } catch (err) {
          console.warn('Failed to check EPUB file', err);
          parseBtn.prop('disabled', true);
          setStatus('Failed to check EPUB file.', 'error');
          setCoverImage(null);
          updateSummaryFromData(null);
          setRawState({ available: false, visible: false });
        }
      }

      let jobPollTimer = null;
      async function pollJob(jobId) {
        if (!jobId) return;
        try {
          const res = await fetchWithRefresh(`/api/job/${encodeURIComponent(jobId)}`);
          if (!res.ok) throw new Error('Job status request failed');
          const data = await res.json();
          console.log("job status:");
          console.log(data);
          const status = data.status || 'queued';
          const progress = typeof data.progress === 'number' ? data.progress : 0;
          const message = data.progress_msg || '';
          setJobStatus(status, progress, message);

          if (status === 'success') {
            await loadResult();
            stopProgress();
            parseBtn.prop('disabled', false);
            return;
          }
          if (status === 'fail' || status === 'cancelled') {
            stopProgress();
            parseBtn.prop('disabled', false);
            return;
          }
          jobPollTimer = setTimeout(() => pollJob(jobId), 1000);
        } catch (err) {
          console.warn('Failed to poll job status', err);
          setStatus('Failed to fetch job status.', 'error');
          stopProgress();
          parseBtn.prop('disabled', false);
        }
      }

      parseBtn.on('click', async () => {
        if (!podTitle) return;
        setStatus('Starting parse...', 'info');
        startProgress();
        parseBtn.prop('disabled', true);
        try {
          console.log("start parsing");
          const res = await fetchWithRefresh('/api/job', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              command: 'parse_epub',
              params: [{ key: 'book_title', value: podTitle }]
            })
          });
          if (!res.ok) throw new Error('Parse request failed');
          const data = await res.json();
          const jobId = data.id;
          console.log("job created:", jobId);
          if (!jobId) throw new Error('Missing job id');
          setStatus('Parsing started. Waiting for output...', 'info');
          setJobStatus('queued', 0, 'Queued.');
          setRawState({ available: false, visible: rawDataVisible });
          if (jobPollTimer) clearTimeout(jobPollTimer);
          pollJob(jobId);
        } catch (err) {
          console.warn('Failed to start parsing', err);
          setStatus('Failed to start parsing.', 'error');
          stopProgress();
          parseBtn.prop('disabled', false);
        }
      });

      showRawBtn.on('click', () => {
        if (!rawDataAvailable) return;
        setRawState({ visible: !rawDataVisible });
      });

      setRawState({ available: false, visible: false });
      checkEpub();
    });
  </script>
</body>
</html>
