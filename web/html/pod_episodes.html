<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Podcast Episodes</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"  crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.7/css/jquery.dataTables.min.css">
  <link rel="stylesheet" href="/css/pod_episodes.css">
</head>
<body>
  <div class="page-shell">
    <header class="header">
      <div>
        <h1 id="pod-title">Podcast Episodes</h1>
        <p class="subtitle" id="pod-subtitle">Loading podcast info…</p>
      </div>
      <div id="model-selector" class="d-none d-flex align-items-center gap-2">
        <label class="form-label mb-0 text-secondary small" for="model-select">Model</label>
        <select class="form-select form-select-sm" id="model-select" style="width:auto"></select>
      </div>
    </header>

    <div class="status" id="status"></div>

    <div class="table-container">
      <table id="episodes-table" class="display table table-striped" style="width:100%">
        <thead>
          <tr>
            <th>Index</th>
            <th>Title</th>
            <th class="col-duration">Duration</th>
            <th></th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js"  crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"  crossorigin="anonymous"></script>
  <script src="https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js"></script>
  <script src="/js/main.js"></script>
  <script>
    (function() {
      const statusEl = document.getElementById('status');
      const titleEl = document.getElementById('pod-title');
      const subtitleEl = document.getElementById('pod-subtitle');
      const tableEl = document.getElementById('episodes-table');
      const params = new URLSearchParams(window.location.search);
      const podId = params.get('pod_id');
      let table = null;
      let podEpisodes = [];
      let pendingQueueRefresh = false;
      let publishingModel = false;

      function showStatus(message, isError = false) {
        statusEl.textContent = message;
        statusEl.style.display = 'block';
        statusEl.style.borderColor = isError ? '#f5c2c7' : '#e6e9f2';
        statusEl.style.background = isError ? '#fff5f5' : '#fff';
        statusEl.style.color = isError ? '#842029' : '#4b5675';
      }

      async function recordLocation() {
        console.log("recordLocation for pod_episodes");
        const uri = `${window.location.pathname}${window.location.search}`;
        try {
          await fetchWithRefresh('/api/last_location', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ uri })
          });
        } catch (err) {
          console.warn('Failed to record last location', err);
        }
      }

      function buildRows(queueIds) {
        const rows = (podEpisodes || []).map(ep => {
          const idxVal = ep.index || '';
          const isQueued = queueIds.has(`${podId}:${idxVal}`);
          const queueBtn = isQueued
            ? ''
            : `
              <button type="button"
                      class="btn btn-sm btn-outline-secondary btn-add-queue"
                      data-episode-idx="${idxVal}">
                <i class="fa-solid fa-plus"></i> <span>Add to queue</span>
              </button>`;
          return ([
            idxVal,
            ep.title || 'Untitled',
            ep.duration || '',
            `
              <div class="actions">
                ${queueBtn}
              </div>
            `
          ]);
        });
        rows.sort((a, b) => {
          const aIdx = Number(a[0]);
          const bIdx = Number(b[0]);
          const aVal = Number.isFinite(aIdx) ? aIdx : Number.MAX_SAFE_INTEGER;
          const bVal = Number.isFinite(bIdx) ? bIdx : Number.MAX_SAFE_INTEGER;
          return aVal - bVal;
        });
        return rows;
      }

      function renderTable(rows) {
        if (table) {
          table.clear();
          table.rows.add(rows);
          table.draw(false);
          return;
        }
        table = $('#episodes-table').DataTable({
          data: rows,
          columns: [
            { title: 'Index' },
            { title: 'Title' },
            { title: 'Duration' },
            { title: 'Actions', orderable: false }
          ],
          paging: true,
          pageLength: 10,
          order: [],
          ordering: false,
          searching: false,
          info: false,
          lengthChange: false
        });
      }

      async function refreshQueueState() {
        if (!table || !podId) return;
        try {
          const queueRes = await fetchWithRefresh('/api/queue');
          if (!queueRes.ok) throw new Error(`Request failed: ${queueRes.status}`);
          const queue = await queueRes.json();
          const queueIds = new Set(queue.map(item => `${item.pod_id}:${item.episode_idx}`));
          renderTable(buildRows(queueIds));
          statusEl.style.display = 'none';
        } catch (err) {
          console.warn('Failed to refresh queue state', err);
        }
      }

      async function loadPod() {
        if (!podId) {
          showStatus('Missing pod_id in URL.', true);
          subtitleEl.textContent = 'Unable to load episodes.';
          return;
        }

        showStatus('Loading episodes...');
        try {
          const [podsRes, queueRes] = await Promise.all([
            fetchWithRefresh('/api/get_pods'),
            fetchWithRefresh('/api/queue')
          ]);
          if (!podsRes.ok) throw new Error(`Request failed: ${podsRes.status}`);
          if (!queueRes.ok) throw new Error(`Request failed: ${queueRes.status}`);
          const [pods, queue] = await Promise.all([podsRes.json(), queueRes.json()]);
          const queueIds = new Set(queue.map(item => `${item.pod_id}:${item.episode_idx}`));
          const pod = pods.find(p => p.id === podId);
          if (!pod) {
            showStatus('Podcast not found.', true);
            subtitleEl.textContent = 'Unable to load episodes.';
            return;
          }

          titleEl.textContent = pod.title || 'Podcast';
          subtitleEl.textContent = pod.episodes?.length
            ? `${pod.episodes.length} episode${pod.episodes.length === 1 ? '' : 's'}`
            : 'No episodes found.';

          podEpisodes = pod.episodes || [];
          renderTable(buildRows(queueIds));

          statusEl.style.display = 'none';
          if (pendingQueueRefresh) {
            pendingQueueRefresh = false;
            void refreshQueueState();
          }
        } catch (err) {
          showStatus('Failed to load episodes.', true);
          console.error(err);
        }
      }

      async function addToQueue(episodeIdx) {
        if (!episodeIdx) {
          showStatus('Cannot add episode without an index.', true);
          return;
        }
        try {
          const res = await fetchWithRefresh('/api/queue', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              pod_id: podId,
              episode_idx: Number(episodeIdx),
              start_pos: 0
            })
          });
          if (!res.ok) throw new Error(`Request failed: ${res.status}`);
          const data = await res.json();
          if (!data.added) {
            showStatus('Episode is already in your queue.', false);
          } else {
            statusEl.style.display = 'none';
            const btn = document.querySelector(`.btn-add-queue[data-episode-idx="${episodeIdx}"]`);
            if (btn) {
              const container = btn.closest('.actions');
              btn.remove();
              if (container && !container.querySelector('.btn-add-queue')) {
                container.classList.add('queue-added');
              }
            }
            try {
              window.parent?.postMessage({ type: 'queue-updated' }, '*');
            } catch (err) {
              console.warn('Failed to notify parent about queue update', err);
            }
          }
        } catch (err) {
          showStatus('Failed to add to queue.', true);
          console.error(err);
        }
      }

      async function loadModels() {
        if (!podId) return;
        try {
          const res = await fetchWithRefresh(`/api/audio_models/${encodeURIComponent(podId)}`);
          if (!res.ok) return;
          const models = await res.json();
          if (!Array.isArray(models) || models.length < 2) return;
          const sel = document.getElementById('model-select');
          sel.innerHTML = '';
          models.forEach(m => {
            const opt = document.createElement('option');
            opt.value = m;
            opt.textContent = m;
            sel.appendChild(opt);
          });
          document.getElementById('model-selector').classList.remove('d-none');
        } catch (err) {
          console.warn('Failed to load audio models', err);
        }
      }

      async function switchModel(modelName) {
        if (!podId || publishingModel) return;
        publishingModel = true;
        showStatus(`Switching to model "${modelName}"…`);
        try {
          const res = await fetchWithRefresh(
            `/api/feed/${encodeURIComponent(podId)}?model_name=${encodeURIComponent(modelName)}`,
            { method: 'POST' }
          );
          if (!res.ok) throw new Error(`Feed publish failed: ${res.status}`);
          await loadPod();
        } catch (err) {
          showStatus('Failed to switch model.', true);
          console.error(err);
        } finally {
          publishingModel = false;
        }
      }

      window.addEventListener('DOMContentLoaded', () => {
        recordLocation();
        loadPod();
        loadModels();
        $('#episodes-table').on('click', '.btn-add-queue', function () {
          const idx = this.getAttribute('data-episode-idx');
          addToQueue(idx);
        });
        document.getElementById('model-select').addEventListener('change', function () {
          switchModel(this.value);
        });
      });

      window.addEventListener('message', (event) => {
        if (event?.data?.type !== 'queue-updated') return;
        if (!table) {
          pendingQueueRefresh = true;
          return;
        }
        const hasActions = !!tableEl.querySelector('.actions');
        if (hasActions) {
          void refreshQueueState();
        }
      });
    })();
  </script>
</body>
</html>
