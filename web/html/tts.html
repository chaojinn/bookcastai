<!--
this page should use epub.css under css folder for styling, create empty style file if not exist
this page should use jquery and bootstrap in the same style as index.html
this page will have a responsive design and look proper on all device sizes
this page will have:
a pod_title parameter passed via URI
a combo box to select tts model (hardcoded to "kokoro-tts" for now)
a combo box to select voice. a tts.py should be generated under api folder to handle tts request. GET /api/tts/voices should be implemented in tts.py(use get_english_voices in kokoro.py). 
For now any other model name will return empty list
it should take model name as parameter and return a list of voices names and code to display in combo box.
a slider to select speed: range 0.6-1.2, default 1.0, each step 0.1
a checkbox for overwrite: bool, default false
a button to start tts, when clicked, it should POST to /api/job with command="tts", params={book_title:pod_title, model_name:model, voice:voice_code, speed:speed, overwrite:overwrite},
job_queue.py should register the job to the queue, generate a handler to handle tts command, it should call convert_epub_to_pod function to generate tts.
the page should poll /api/job/{job_id} to get the job status, and display both progess and progress_message in a progress bar

when page loaded, it should call /api/epub_result/{pod_title} to check if json file exists, it not , disable all controls on the page. 

-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TTS Generator</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/epub.css">
</head>
<body>
  <main class="page-shell">
    <header class="page-header">
      <div>
        <h1>TTS Generator</h1>
        <p class="subtitle">Pod: <span id="pod-title">Unknown</span></p>
      </div>
      <button class="btn btn-primary" id="start-btn" disabled>
        <i class="fa-solid fa-play"></i> Start TTS
      </button>
    </header>

    <section class="panel">
      <div class="row g-3">
        <div class="col-12 col-md-6">
          <label class="form-label" for="model-select">TTS model</label>
          <select class="form-select" id="model-select"></select>
        </div>
        <div class="col-12 col-md-6">
          <label class="form-label" for="voice-select">Voice</label>
          <select class="form-select" id="voice-select" disabled></select>
        </div>
        <div class="col-12 col-md-6">
          <label class="form-label" for="speed-range">
            Speed <span id="speed-value">1.00x</span>
          </label>
          <input
            class="form-range"
            id="speed-range"
            type="range"
            min="0.6"
            max="1.2"
            step="0.05"
            value="1.0"
          >
        </div>
        <div class="col-12 col-md-6 d-flex align-items-end">
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="overwrite-check">
            <label class="form-check-label" for="overwrite-check">Overwrite existing audio</label>
          </div>
        </div>
      </div>

      <div class="controls mt-3">
        <div class="progress d-none" role="progressbar" aria-label="TTS progress">
          <div id="progress-bar" class="progress-bar" style="width: 0%"></div>
        </div>
      </div>
      <div id="status-bar" class="status-bar">Ready.</div>
    </section>
  </main>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
  <script src="/js/main.js"></script>
  <script>
    $(function () {
      const params = new URLSearchParams(window.location.search);
      const podTitle = params.get('pod_title');

      const podTitleEl = $('#pod-title');
      const modelSelect = $('#model-select');
      const voiceSelect = $('#voice-select');
      const speedRange = $('#speed-range');
      const speedValue = $('#speed-value');
      const overwriteCheck = $('#overwrite-check');
      const startBtn = $('#start-btn');
      const statusBar = $('#status-bar');
      const progressBar = $('#progress-bar');
      const progressWrap = $('.progress');

      let jobPollTimer = null;
      let voicesAvailable = false;
      let pageReady = false;
      let jobRunning = false;
      let feedPublishing = false;

      function setStatus(message, variant) {
        statusBar
          .removeClass('status-error status-success status-info')
          .addClass(variant ? `status-${variant}` : '')
          .text(message || '');
      }

      function startProgress() {
        progressWrap.removeClass('d-none');
        progressBar
          .addClass('progress-bar-striped progress-bar-animated')
          .css('width', '0%')
          .text('');
      }

      function stopProgress() {
        progressBar
          .removeClass('progress-bar-striped progress-bar-animated')
          .css('width', '0%')
          .text('');
        progressWrap.addClass('d-none');
      }

      function updateProgress(value, message) {
        const numeric = Number(value);
        const clamped = Number.isFinite(numeric) ? Math.max(0, Math.min(100, numeric)) : 0;
        const label = message ? `${Math.round(clamped)}% - ${message}` : `${Math.round(clamped)}%`;
        progressBar.css('width', `${clamped}%`).text(label);
        return Math.round(clamped);
      }

      function setJobStatus(status, progress, message) {
        const percent = updateProgress(progress, message);
        const text = message ? `${percent}% - ${message}` : `${percent}%`;
        console.log("progress:"+ percent + ", message:" + message);
        if (status === 'success') {
          setStatus(text, 'success');
          return;
        }
        if (status === 'fail' || status === 'cancelled') {
          setStatus(text, 'error');
          return;
        }
        setStatus(text, 'info');
      }

      function updateSpeedLabel(value) {
        const numeric = Number(value);
        const display = Number.isFinite(numeric) ? numeric.toFixed(2) : '1.00';
        speedValue.text(`${display}x`);
      }

      function updateControlState() {
        const canStart = pageReady && voicesAvailable && !jobRunning;
        startBtn.prop('disabled', !canStart);
        modelSelect.prop('disabled', !pageReady || jobRunning);
        voiceSelect.prop('disabled', !pageReady || jobRunning || !voicesAvailable);
        speedRange.prop('disabled', !pageReady || jobRunning);
        overwriteCheck.prop('disabled', !pageReady || jobRunning);
      }

      function populateModels() {
        modelSelect.empty();
        modelSelect.append(
          $('<option>', { value: 'kokoro-tts', text: 'Kokoro (kokoro-tts)' })
        );
        modelSelect.val('kokoro-tts');
      }

      function setVoiceOptions(voices) {
        voiceSelect.empty();
        if (!Array.isArray(voices) || voices.length === 0) {
          voiceSelect.append(
            $('<option>', { value: '', text: 'No voices available' })
          );
          voicesAvailable = false;
          updateControlState();
          return;
        }
        voices.forEach((voice) => {
          voiceSelect.append(
            $('<option>', { value: voice.code, text: voice.name })
          );
        });
        voicesAvailable = true;
        voiceSelect.val(voices[0].code);
        updateControlState();
      }

      async function loadVoices(modelName) {
        if (!modelName) {
          setVoiceOptions([]);
          return;
        }
        try {
          setStatus('Loading voices...', 'info');
          const res = await fetchWithRefresh(`/api/tts/voices?model_name=${encodeURIComponent(modelName)}`);
          if (!res.ok) throw new Error('Voice request failed');
          const data = await res.json();
          setVoiceOptions(data);
          if (Array.isArray(data) && data.length) {
            setStatus('Voices loaded.', 'success');
          } else {
            setStatus('No voices available for this model.', 'info');
          }
        } catch (err) {
          console.warn('Failed to load voices', err);
          setVoiceOptions([]);
          setStatus('Failed to load voices.', 'error');
        }
      }

      async function checkParsedJson() {
        if (!podTitle) {
          setStatus('Missing pod_title in URL.', 'error');
          pageReady = false;
          updateControlState();
          return;
        }
        podTitleEl.text(podTitle);
        setStatus('Checking parsed EPUB JSON...', 'info');
        try {
          const res = await fetchWithRefresh(`/api/epub_result/${encodeURIComponent(podTitle)}`);
          if (res.ok) {
            pageReady = true;
            setStatus('Ready to generate TTS.', 'success');
            updateControlState();
            await loadVoices(modelSelect.val());
            return;
          }
          if (res.status === 404) {
            pageReady = false;
            setStatus('Parsed EPUB JSON not found. Run EPUB parsing first.', 'error');
            updateControlState();
            return;
          }
          throw new Error('Unexpected response');
        } catch (err) {
          console.warn('Failed to check EPUB result', err);
          pageReady = false;
          setStatus('Failed to check parsed EPUB JSON.', 'error');
          updateControlState();
        }
      }

      async function pollJob(jobId) {
        if (!jobId) return;
        try {
          const res = await fetchWithRefresh(`/api/job/${encodeURIComponent(jobId)}`);
          if (!res.ok) throw new Error('Job status request failed');
          const data = await res.json();
          const status = data.status || 'queued';
          const progress = typeof data.progress === 'number' ? data.progress : 0;
          const message = data.progress_msg || '';
          setJobStatus(status, progress, message);

          if (status === 'success') {
            stopProgress();
            jobRunning = false;
            updateControlState();
            if (!feedPublishing) {
              feedPublishing = true;
              try {
                setStatus('Publishing feed...', 'info');
                const feedRes = await fetchWithRefresh(`/api/feed/${encodeURIComponent(podTitle)}`, {
                  method: 'POST'
                });
                if (!feedRes.ok) throw new Error('Feed publish failed');
                setStatus('Feed published successfully.', 'success');
              } catch (err) {
                console.warn('Failed to publish feed', err);
                setStatus('TTS complete, but failed to publish feed.', 'error');
              }
            }
            return;
          }
          if (status === 'fail' || status === 'cancelled') {
            stopProgress();
            jobRunning = false;
            updateControlState();
            return;
          }
          jobPollTimer = setTimeout(() => pollJob(jobId), 1000);
        } catch (err) {
          console.warn('Failed to poll job status', err);
          setStatus('Failed to fetch job status.', 'error');
          stopProgress();
          jobRunning = false;
          updateControlState();
        }
      }

      startBtn.on('click', async () => {
        if (!podTitle) return;
        const modelName = modelSelect.val();
        const voiceCode = voiceSelect.val();
        const speed = Number(speedRange.val());
        const overwrite = overwriteCheck.is(':checked');

        jobRunning = true;
        updateControlState();
        setStatus('Starting TTS job...', 'info');
        startProgress();
        try {
          const res = await fetchWithRefresh('/api/job', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              command: 'tts',
              params: [
                { key: 'book_title', value: podTitle },
                { key: 'model_name', value: modelName },
                { key: 'voice', value: voiceCode },
                { key: 'speed', value: speed },
                { key: 'overwrite', value: overwrite }
              ]
            })
          });
          if (!res.ok) throw new Error('TTS request failed');
          const data = await res.json();
          const jobId = data.id;
          if (!jobId) throw new Error('Missing job id');
          setJobStatus('queued', 0, 'Queued.');
          if (jobPollTimer) clearTimeout(jobPollTimer);
          pollJob(jobId);
        } catch (err) {
          console.warn('Failed to start TTS', err);
          setStatus('Failed to start TTS.', 'error');
          stopProgress();
          jobRunning = false;
          updateControlState();
        }
      });

      speedRange.on('input', () => {
        updateSpeedLabel(speedRange.val());
      });

      modelSelect.on('change', () => {
        loadVoices(modelSelect.val());
      });

      populateModels();
      updateSpeedLabel(speedRange.val());
      updateControlState();
      checkParsedJson();
    });
  </script>
</body>
</html>
